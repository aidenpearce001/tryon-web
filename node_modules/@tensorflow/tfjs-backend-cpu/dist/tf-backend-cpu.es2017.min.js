/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("@tensorflow/tfjs-core"),require("seedrandom")):"function"==typeof define&&define.amd?define(["exports","@tensorflow/tfjs-core","seedrandom"],t):t((e=e||self).tf=e.tf||{},e.tf,e.seedrandom)}(this,(function(e,t,a){"use strict";function n(e,a){Array.isArray(e)||(e=[e]),e.forEach(e=>{null!=e&&t.util.assert("complex64"!==e.dtype,()=>`${a} does not support complex64 tensors in the CPU backend.`)})}const s=t.kernel_impls.nonMaxSuppressionV3Impl,r=t.kernel_impls.split,o=t.kernel_impls.tile,i=t.kernel_impls.topkImpl,d=t.kernel_impls.whereImpl;function l(e,a,n,s){if("linear"===n)return e.linear(a);if("relu"===n)return e.relu(a);if("elu"===n)return t.elu(a);if("relu6"===n)return e.relu6(a);if("prelu"===n)return e.prelu(a,s);throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}class c extends t.KernelBackend{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new t.DataStorage(this,t.engine())}write(e,a,n){this.firstUse&&(this.firstUse=!1,t.env().get("IS_NODE")&&t.backend_util.warn("\n============================\nHi there ðŸ‘‹. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"));const s={};return this.data.set(s,{values:e,dtype:n,refCount:1}),s}makeTensorInfo(e,t,a){return{dataId:this.write(a,e,t),shape:e,dtype:t}}incRef(e){this.data.get(e).refCount++}decRef(e){if(this.data.has(e)){this.data.get(e).refCount--}}move(e,t,a,n){this.data.set(e,{values:t,dtype:n,refCount:1})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:a,complexTensorInfos:n}=this.data.get(e);if("complex64"===a){const e=this.readSync(n.real.dataId),a=this.readSync(n.imag.dataId);return t.backend_util.mergeRealAndImagArrays(e,a)}return this.data.get(e).values}bufferSync(e){const a=this.readSync(e.dataId);let n=a;if("string"===e.dtype)try{n=a.map(e=>t.util.decodeString(e))}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return t.buffer(e.shape,e.dtype,n)}makeOutput(e,a,n){const s=this.write(e,a,n);return t.engine().makeTensorFromDataId(s,a,n,this)}disposeData(e){if(this.data.has(e)){const{complexTensorInfos:t}=this.data.get(e);null!=t&&(this.disposeData(t.real.dataId),this.disposeData(t.imag.dataId)),this.data.delete(e)}}disposeIntermediateTensorInfo(e){const t=e.dataId;if(this.data.has(t)){const e=this.data.get(t);e.refCount--,e.refCount<1&&this.disposeData(t)}}async time(e){const a=t.util.now();return e(),{kernelMs:t.util.now()-a}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}stridedSlice(e,a,s,r){n(e,"stridedSlice");const o=t.slice_util.computeOutShape(a,s,r);if(o.some(e=>0===e))return t.tensor([],o);const i=t.buffer(o,e.dtype),d=this.bufferSync(e);for(let e=0;e<i.size;e++){const t=i.indexToLoc(e),n=new Array(t.length);for(let e=0;e<n.length;e++)n[e]=t[e]*r[e]+a[e];i.set(d.get(...n),...t)}return i.toTensor()}diag(e){const a=this.readSync(e.dataId),n=t.buffer([e.size,e.size],e.dtype),s=n.values;for(let t=0;t<a.length;t++)s[t*e.size+t]=a[t];return n.toTensor()}unstack(e,a){const n=e.shape[a],s=new Array(e.rank-1);let r=0;for(let t=0;t<e.rank;t++)t!==a&&(s[r++]=e.shape[t]);const o=new Array(e.rank).fill(0),i=e.shape.slice();i[a]=1;const d=new Array(n);for(let n=0;n<d.length;n++)o[a]=n,d[n]=t.slice(e,o,i).reshape(s);return d}reverse(e,a){n(e,"reverse");const s=t.buffer(e.shape,e.dtype),r=this.bufferSync(e);for(let t=0;t<s.size;t++){const n=s.indexToLoc(t),o=n.slice();a.forEach(t=>o[t]=e.shape[t]-1-o[t]),s.set(r.get(...o),...n)}return s.toTensor()}neg(e){return n(e,"neg"),t.mul(t.scalar(-1),e)}addN(e){n(e,"addN");const a=e.map(e=>this.readSync(e.dataId)),s=t.buffer(e[0].shape,e[0].dtype),r=s.values;for(let t=0;t<e.length;t++){const e=a[t];for(let t=0;t<r.length;t++)r[t]+=e[t]}return s.toTensor()}softmax(e,a){const n=t.util.parseAxisParam([a],e.shape),s=t.max(e,n),r=t.backend_util.expandShapeToKeepDim(s.shape,n),o=t.sub(e,s.reshape(r)),i=t.exp(o),d=this.sum(i,n).reshape(r);return t.div(i,d)}pow(e,t){return n([e,t],"pow"),this.broadcastedBinaryOp(e,t,e.dtype,(e,t)=>Math.pow(e,t))}batchMatMul(e,a,s,r){n([e,a],"matMul");const o=s?e.shape[1]:e.shape[2],i=s?e.shape[2]:e.shape[1],d=r?a.shape[1]:a.shape[2],l=e.shape[0],c=this.readSync(e.dataId),u=this.readSync(a.dataId),[p,h,f]=s?[e.strides[0],1,e.strides[1]]:[e.strides[0],e.strides[1],1],[m,k,g]=r?[1,a.strides[1],a.strides[0]]:[a.strides[1],1,a.strides[0]],I=i*d,b=t.buffer([l,i,d],e.dtype),y=b.values,S=this.blockSize;for(let e=0;e<l;e++)for(let t=0;t<i;t+=S)for(let a=0;a<d;a+=S)for(let n=0;n<o;n+=S){const s=Math.min(t+S,i),r=Math.min(a+S,d),l=Math.min(n+S,o);for(let o=t;o<s;o++)for(let t=a;t<r;t++){let a=0;for(let s=n;s<l;s++)a+=c[e*p+o*h+s*f]*u[s*m+t*k+e*g];y[e*I+(o*d+t)]+=a}}return b.toTensor()}fusedBatchMatMul({a:e,b:a,transposeA:n,transposeB:s,bias:r,activation:o,preluActivationWeights:i}){let d=this.batchMatMul(e,a,n,s);return r&&(d=t.add(d,r)),o&&(d=l(this,d,o,i)),d}floorDiv(e,t){n([e,t],"floorDiv");return this.broadcastedBinaryOp(e,t,"int32",(e,t)=>Math.floor(e/t))}sum(e,a){n(e,"sum"),t.backend_util.assertAxesAreInnerMostDims("sum",a,e.rank);const[s,r]=t.backend_util.computeOutAndReduceShapes(e.shape,a),o=t.upcastType(e.dtype,"int32"),i=t.zeros(s,o),d=t.util.sizeFromShape(r),l=this.readSync(i.dataId),c=this.readSync(e.dataId);for(let e=0;e<l.length;++e){const t=e*d;let a=0;for(let e=0;e<d;++e)a+=c[t+e];l[e]=a}return i}prod(e,a){n(e,"sum");const[s,r]=t.backend_util.computeOutAndReduceShapes(e.shape,a),o=t.upcastType(e.dtype,"int32"),i=t.zeros(s,o),d=t.util.sizeFromShape(r),l=this.readSync(i.dataId),c=this.readSync(e.dataId);for(let e=0;e<l.length;++e){const t=e*d;let a=1;for(let e=0;e<d;++e)a*=c[t+e];l[e]=a}return i}unsortedSegmentSum(e,a,s){n(e,"unsortedSegmentSum");const r=[],o=e.rank-a.rank;for(let e=0;e<o;++e)a=a.expandDims(e+1);for(let n=0;n<s;++n){const s=t.scalar(n,"int32"),o=t.equal(s,a).asType("float32").mul(e).sum(0);r.push(o)}return t.stack(r)}argMin(e,a){n(e,"argMin");const s=[a];t.backend_util.assertAxesAreInnerMostDims("argMin",s,e.rank);const[r,o]=t.backend_util.computeOutAndReduceShapes(e.shape,s),i=t.zeros(r,"int32"),d=t.util.sizeFromShape(o),l=this.readSync(i.dataId),c=this.readSync(e.dataId);for(let e=0;e<l.length;++e){const t=e*d;let a=c[t],n=0;for(let e=0;e<d;++e){const s=c[t+e];s<a&&(a=s,n=e)}l[e]=n}return i}argMax(e,a){n(e,"argMax");const s=[a];t.backend_util.assertAxesAreInnerMostDims("argMax",s,e.rank);const[r,o]=t.backend_util.computeOutAndReduceShapes(e.shape,s),i=t.zeros(r,"int32"),d=t.util.sizeFromShape(o),l=this.readSync(i.dataId),c=this.readSync(e.dataId);for(let e=0;e<l.length;++e){const t=e*d;let a=c[t],n=0;for(let e=0;e<d;++e){const s=c[t+e];s>a&&(a=s,n=e)}l[e]=n}return i}cumsum(e,a,s,r){if(n(e,"cumsum"),a!==e.rank-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${e.rank-1} `+`but got axis=${a}`);const o=t.upcastType(e.dtype,"int32"),i=t.zeros(e.shape,o),d=this.readSync(i.dataId),l=this.readSync(e.dataId),c=e.shape[e.rank-1],u=r?(e,t)=>e+c-t-1:(e,t)=>e+t;for(let e=0;e<l.length;e+=c)for(let t=0;t<c;t++){const a=u(e,t);if(0===t)d[a]=s?0:l[a];else{const n=u(e,t-1);d[a]=s?l[n]+d[n]:l[a]+d[n]}}return i}equal(e,t){return n([e,t],"equal"),this.broadcastedBinaryOp(e,t,"bool",(e,t)=>e===t?1:0)}notEqual(e,t){return n([e,t],"notEqual"),this.broadcastedBinaryOp(e,t,"bool",(e,t)=>e!==t?1:0)}less(e,t){return n([e,t],"less"),this.broadcastedBinaryOp(e,t,"bool",(e,t)=>e<t?1:0)}lessEqual(e,t){return n([e,t],"lessEqual"),this.broadcastedBinaryOp(e,t,"bool",(e,t)=>e<=t?1:0)}greater(e,t){return n([e,t],"greater"),this.broadcastedBinaryOp(e,t,"bool",(e,t)=>e>t?1:0)}greaterEqual(e,t){return n([e,t],"greaterEqual"),this.broadcastedBinaryOp(e,t,"bool",(e,t)=>e>=t?1:0)}logicalAnd(e,t){return n([e,t],"logicalAnd"),this.broadcastedBinaryOp(e,t,"bool",(e,t)=>e&&t)}logicalOr(e,t){return n([e,t],"logicalOr"),this.broadcastedBinaryOp(e,t,"bool",(e,t)=>e||t)}select(e,a,s){n([e,a,s],"select");const r=this.readSync(e.dataId),o=this.readSync(a.dataId),i=this.readSync(s.dataId),d=t.zeros(a.shape,t.upcastType(a.dtype,s.dtype)),l=this.readSync(d.dataId);let c=0;const u=0===e.rank||e.rank>1||1===a.rank?1:t.util.sizeFromShape(a.shape.slice(1));for(let e=0;e<r.length;e++)for(let t=0;t<u;t++)1===r[e]?l[c++]=o[e]:l[c++]=i[e];return d}where(e){n([e],"where");const t=this.readSync(e.dataId);return d(e.shape,t)}topk(e,t,a){n(e,"topk");const s=this.readSync(e.dataId);return i(s,e.shape,e.dtype,t,a)}min(e,a){n(e,"min"),t.backend_util.assertAxesAreInnerMostDims("min",a,e.rank);const[s,r]=t.backend_util.computeOutAndReduceShapes(e.shape,a),o=t.zeros(s,e.dtype),i=t.util.sizeFromShape(r),d=this.readSync(o.dataId),l=this.readSync(e.dataId);for(let e=0;e<d.length;++e){const t=e*i;let a=l[t];for(let e=0;e<i;++e){const n=l[t+e];n<a&&(a=n)}d[e]=a}return o}minimum(e,t){return n([e,t],"minimum"),this.broadcastedBinaryOp(e,t,e.dtype,(e,t)=>Math.min(e,t))}mod(e,t){return n([e,t],"mod"),this.broadcastedBinaryOp(e,t,e.dtype,(e,t)=>{const a=e%t;return e<0&&t<0||e>=0&&t>=0?a:(a+t)%t})}maximum(e,t){return n([e,t],"maximum"),this.broadcastedBinaryOp(e,t,e.dtype,(e,t)=>Math.max(e,t))}all(e,a){n(e,"all"),t.backend_util.assertAxesAreInnerMostDims("all",a,e.rank);const[s,r]=t.backend_util.computeOutAndReduceShapes(e.shape,a),o=t.zeros(s,e.dtype),i=t.util.sizeFromShape(r),d=this.readSync(o.dataId),l=this.readSync(e.dataId);for(let e=0;e<d.length;++e){const t=e*i;let a=l[t];for(let e=0;e<i;++e){const n=l[t+e];a=a&&n}d[e]=a}return o}any(e,a){n(e,"any"),t.backend_util.assertAxesAreInnerMostDims("any",a,e.rank);const[s,r]=t.backend_util.computeOutAndReduceShapes(e.shape,a),o=t.zeros(s,e.dtype),i=t.util.sizeFromShape(r),d=this.readSync(o.dataId),l=this.readSync(e.dataId);for(let e=0;e<d.length;++e){const t=e*i;let a=l[t];for(let e=0;e<i;++e){const n=l[t+e];a=a||n}d[e]=a}return o}squaredDifference(e,t){return n([e,t],"squaredDifference"),this.broadcastedBinaryOp(e,t,e.dtype,(e,t)=>{const a=e-t;return a*a})}linear(e){return e}relu(e){n(e,"relu");const a=t.zeros(e.shape,e.dtype),s=this.readSync(a.dataId),r=this.readSync(e.dataId);for(let e=0;e<r.length;++e)s[e]=Math.max(0,r[e]);return a}relu6(e){n(e,"relu");const a=t.zeros(e.shape,e.dtype),s=this.readSync(a.dataId),r=this.readSync(e.dataId);for(let e=0;e<r.length;++e)s[e]=Math.min(Math.max(0,r[e]),6);return a}prelu(e,t){return n([e,t],"prelu"),this.broadcastedBinaryOp(e,t,e.dtype,(e,t)=>e<0?t*e:e)}eluDer(e,t){n([e,t],"eluDer");const a=new Float32Array(t.size),s=this.readSync(t.dataId),r=this.readSync(e.dataId);for(let e=0;e<s.length;++e){const t=s[e];a[e]=t>=1?r[e]:r[e]*(t+1)}return this.makeOutput(a,t.shape,"float32")}atan2(e,t){return n([e,t],"atan2"),this.broadcastedBinaryOp(e,t,e.dtype,(e,t)=>Math.atan2(e,t))}fusedConv2d({input:e,filter:a,convInfo:n,bias:s,activation:r,preluActivationWeights:o}){let i=this.conv2d(e,a,n);return s&&(i=t.add(i,s)),r&&(i=l(this,i,r,o)),i}conv2d(e,a,s){n([e,a],"conv2d");const r=s.filterHeight,o=s.filterWidth,i=s.dilationHeight,d=s.dilationWidth,l=s.padInfo.left,c=s.padInfo.top,u="channelsLast"===s.dataFormat,p=t.buffer(s.outShape,e.dtype),h=e.strides[0],f=u?e.strides[1]:e.strides[2],m=u?e.strides[2]:1,k=u?1:e.strides[1],g=p.strides[0],I=u?p.strides[1]:p.strides[2],b=u?p.strides[2]:1,y=u?1:p.strides[1],S=this.readSync(e.dataId),T=this.readSync(a.dataId),N=p.values;for(let e=0;e<s.batchSize;++e){const t=e*h,n=e*g;for(let e=0;e<s.outHeight;++e){const u=n+e*I,p=e*s.strideHeight-c;for(let e=0;e<r;e++){const n=p+e*i;if(n<0||n>=s.inHeight)continue;const r=e*a.strides[0],c=t+n*f;for(let e=0;e<s.outWidth;++e){const t=u+e*b,n=e*s.strideWidth-l;for(let e=0;e<o;e++){const o=n+e*d;if(o<0||o>=s.inWidth)continue;const i=c+o*m;let l=r+e*a.strides[1];for(let e=0;e<s.inChannels;++e){const a=S[i+e*k];for(let e=0;e<s.outChannels;++e)N[t+e*y]+=a*T[l+e];l+=s.outChannels}}}}}}return p.toTensor()}conv3d(e,a,n){const s=n.filterDepth,r=n.filterHeight,o=n.filterWidth,i=n.dilationDepth,d=n.dilationHeight,l=n.dilationWidth,c=n.padInfo.front,u=n.padInfo.left,p=n.padInfo.top,h=t.buffer(n.outShape,e.dtype),f=this.readSync(e.dataId),m=this.readSync(a.dataId),k=h.values;for(let t=0;t<n.batchSize;++t){const g=t*e.strides[0],I=t*h.strides[0];for(let t=0;t<n.outDepth;++t){const b=I+t*h.strides[1],y=t*n.strideDepth-c;for(let t=0;t<s;t++){const s=y+t*i;if(s<0||s>=n.inDepth)continue;const c=t*a.strides[0],I=g+s*e.strides[1];for(let t=0;t<n.outHeight;++t){const s=b+t*h.strides[2],i=t*n.strideHeight-p;for(let t=0;t<r;t++){const r=i+t*d;if(r<0||r>=n.inHeight)continue;const p=c+t*a.strides[1],h=I+r*e.strides[2];for(let e=0;e<n.outWidth;++e){const t=s+e*n.outChannels,r=e*n.strideWidth-u;for(let e=0;e<o;e++){const s=r+e*l;if(s<0||s>=n.inWidth)continue;const o=p+e*a.strides[2],i=h+s*n.inChannels;let d=o;for(let e=0;e<n.inChannels;++e){const a=f[i+e];for(let e=0;e<n.outChannels;++e)k[t+e]+=a*m[d+e];d+=n.outChannels}}}}}}}}return h.toTensor()}conv2dDerInput(e,a,s){n([e,a],"conv2dDerInput");const r=t.buffer(s.inShape,"float32"),o=r.values,i=this.readSync(e.dataId),d=this.readSync(a.dataId),[l,c,u]=a.strides,{batchSize:p,filterHeight:h,filterWidth:f,inChannels:m,inHeight:k,inWidth:g,outChannels:I,outHeight:b,outWidth:y,strideHeight:S,strideWidth:T,dataFormat:N}=s,x=h-1-s.padInfo.top,M=f-1-s.padInfo.left,F="channelsLast"===N,v=r.strides[0],A=F?r.strides[1]:r.strides[2],D=F?r.strides[2]:1,z=F?1:r.strides[1],_=e.strides[0],W=F?e.strides[1]:e.strides[2],H=F?e.strides[2]:1,w=F?1:e.strides[1];for(let e=0;e<p;++e)for(let t=0;t<m;++t)for(let a=0;a<k;++a){const n=a-x,s=Math.max(0,Math.ceil(n/S)),r=Math.min(b,(h+n)/S);for(let p=0;p<g;++p){const m=p-M,k=Math.max(0,Math.ceil(m/T)),g=Math.min(y,(f+m)/T);let b=0;for(let a=s;a<r;++a){const s=a*S-n;for(let n=k;n<g;++n){const r=_*e+W*a+H*n,o=l*(h-1-s)+c*(f-1-(n*T-m))+u*t;for(let e=0;e<I;++e){b+=i[r+w*e]*d[o+e]}}}o[v*e+A*a+D*p+z*t]=b}}return r.toTensor()}conv3dDerInput(e,a,n){const s=t.buffer(n.inShape,"float32"),r=s.values,[o,i,d,l]=s.strides,c=this.readSync(e.dataId),[u,p,h,f]=e.strides,m=this.readSync(a.dataId),[k,g,I,b]=a.strides,{batchSize:y,filterDepth:S,filterHeight:T,filterWidth:N,inChannels:x,inDepth:M,inHeight:F,inWidth:v,outChannels:A,outDepth:D,outHeight:z,outWidth:_,strideDepth:W,strideHeight:H,strideWidth:w}=n,C=S-1-n.padInfo.front,E=T-1-n.padInfo.top,B=N-1-n.padInfo.left;for(let e=0;e<y;++e)for(let t=0;t<x;++t)for(let a=0;a<M;++a){const n=a-C,s=Math.max(0,Math.ceil(n/W)),y=Math.min(D,(S+n)/W);for(let x=0;x<F;++x){const M=x-E,F=Math.max(0,Math.ceil(M/H)),D=Math.min(z,(T+M)/H);for(let z=0;z<v;++z){const v=z-B,C=Math.max(0,Math.ceil(v/w)),E=Math.min(_,(N+v)/w);let O=0;for(let a=s;a<y;++a){const s=a*W-n;for(let n=F;n<D;++n){const r=n*H-M;for(let o=C;o<E;++o){const i=u*e+p*a+h*n+f*o,d=k*(S-1-s)+g*(T-1-r)+I*(N-1-(o*w-v))+b*t;for(let e=0;e<A;++e){O+=c[i+e]*m[d+e]}}}}r[o*e+i*a+d*x+l*z+t]=O}}}return s.toTensor()}conv2dDerFilter(e,a,s){n([e,a],"conv2dDerFilter");const r=s.strideHeight,o=s.strideWidth,i=s.filterHeight,d=s.filterWidth,l="channelsLast"===s.dataFormat,c=t.buffer(s.filterShape,"float32"),u=s.padInfo.left,p=s.padInfo.top,h=this.bufferSync(e),f=this.bufferSync(a);for(let e=0;e<i;++e){const t=Math.max(0,Math.ceil((p-e)/r)),a=Math.min(s.outHeight,(s.inHeight+p-e)/r);for(let n=0;n<d;++n){const i=Math.max(0,Math.ceil((u-n)/o)),d=Math.min(s.outWidth,(s.inWidth+u-n)/o);for(let m=0;m<s.inChannels;++m)for(let k=0;k<s.outChannels;++k){let g=0;for(let c=0;c<s.batchSize;++c)for(let s=t;s<a;++s){const t=e+s*r-p;for(let e=i;e<d;++e){const a=n+e*o-u;g+=l?h.get(c,t,a,m)*f.get(c,s,e,k):h.get(c,m,t,a)*f.get(c,k,s,e)}}c.set(g,e,n,m,k)}}}return c.toTensor()}conv3dDerFilter(e,a,n){const s=n.strideDepth,r=n.strideHeight,o=n.strideWidth,i=n.filterDepth,d=n.filterHeight,l=n.filterWidth,c=t.buffer(n.filterShape,"float32"),u=c.values,[p,h,f,m]=c.strides,k=this.readSync(a.dataId),[g,I,b,y]=a.strides,S=this.readSync(e.dataId),[T,N,x,M]=e.strides,F=n.padInfo.front,v=n.padInfo.left,A=n.padInfo.top;for(let e=0;e<i;++e){const t=Math.max(0,Math.ceil((F-e)/s)),a=Math.min(n.outDepth,(n.inDepth+F-e)/s),i=e*p;for(let c=0;c<d;++c){const d=Math.max(0,Math.ceil((A-c)/r)),p=Math.min(n.outHeight,(n.inHeight+A-c)/r),D=c*h+i;for(let i=0;i<l;++i){const l=Math.max(0,Math.ceil((v-i)/o)),h=Math.min(n.outWidth,(n.inWidth+v-i)/o),z=i*f+D;for(let f=0;f<n.inChannels;++f){const D=f*m+z;for(let m=0;m<n.outChannels;++m){let z=0;for(let u=0;u<n.batchSize;++u){const n=u*T,D=u*g;for(let u=t;u<a;++u){const t=(e+u*s-F)*N+n,a=u*I+D;for(let e=d;e<p;++e){const n=(c+e*r-A)*x+t,s=e*b+a;for(let e=l;e<h;++e){const t=e*y+s;z+=S[(i+e*o-v)*M+n+f]*k[t+m]}}}}u[D+m]=z}}}}}return c.toTensor()}fusedDepthwiseConv2D({input:e,filter:a,convInfo:n,bias:s,activation:r,preluActivationWeights:o}){let i=this.depthwiseConv2D(e,a,n);return s&&(i=t.add(i,s)),r&&(i=l(this,i,r,o)),i}depthwiseConv2D(e,a,s){n([e,a],"depthwiseConv2D");const r=s.filterHeight,o=s.filterWidth,i=s.dilationHeight,d=s.dilationWidth,l=s.padInfo.left,c=s.padInfo.top,u=s.outChannels/s.inChannels,p=t.buffer(s.outShape,e.dtype),h=this.readSync(e.dataId),f=this.readSync(a.dataId),m=p.values;for(let t=0;t<s.batchSize;++t){const n=t*e.strides[0],k=t*p.strides[0];for(let t=0;t<s.outHeight;++t){const g=k+t*p.strides[1],I=t*s.strideHeight-l;for(let t=0;t<r;++t){const r=I+t*i;if(r<0||r>=s.inHeight)continue;const l=t*a.strides[0],k=n+r*e.strides[1];for(let e=0;e<s.outWidth;++e){const t=g+e*p.strides[2],n=e*s.strideWidth-c;for(let e=0;e<o;++e){const r=n+e*d;if(r<0||r>=s.inWidth)continue;const o=l+e*a.strides[1],i=k+r*s.inChannels;let c=t,p=o;for(let e=0;e<s.inChannels;++e){const t=h[i+e];for(let e=0;e<u;++e)m[c+e]+=t*f[p+e];c+=u,p+=u}}}}}}return p.toTensor()}depthwiseConv2DDerInput(e,a,s){n([e,a],"depthwiseConv2DDerInput");const r=t.buffer(s.inShape,"float32"),o=r.values,[i,d,l]=r.strides,c=this.readSync(e.dataId),[u,p,h]=e.strides,f=this.readSync(a.dataId),[m,k,g]=a.strides,{batchSize:I,filterHeight:b,filterWidth:y,inChannels:S,inHeight:T,inWidth:N,outChannels:x,outHeight:M,outWidth:F,strideHeight:v,strideWidth:A}=s,D=b-1-s.padInfo.top,z=y-1-s.padInfo.left,_=x/S;for(let e=0;e<I;++e)for(let t=0;t<S;++t)for(let a=0;a<T;++a){const n=a-D,s=Math.max(0,Math.ceil(n/v)),r=Math.min(M,(b+n)/v);for(let I=0;I<N;++I){const S=I-z,T=Math.max(0,Math.ceil(S/A)),N=Math.min(F,(y+S)/A);let x=0;for(let a=s;a<r;++a){const s=a*v-n;for(let n=T;n<N;++n){const r=u*e+p*a+h*n,o=m*(b-1-s)+k*(y-1-(n*A-S))+g*t;for(let e=0;e<_;++e){x+=c[r+(t*_+e)]*f[o+e]}}}o[i*e+d*a+l*I+t]=x}}return r.toTensor()}depthwiseConv2DDerFilter(e,a,s){n([e,a],"depthwiseConv2DDerFilter");const r=s.strideHeight,o=s.strideWidth,i=s.filterHeight,d=s.filterWidth,l=t.buffer(s.filterShape,"float32"),c=s.padInfo.left,u=s.padInfo.top,p=s.outChannels/s.inChannels,h=this.bufferSync(e),f=this.bufferSync(a);for(let e=0;e<i;++e){const t=Math.max(0,Math.ceil((u-e)/r)),a=Math.min(s.outHeight,(s.inHeight+u-e)/r);for(let n=0;n<d;++n){const i=Math.max(0,Math.ceil((c-n)/o)),d=Math.min(s.outWidth,(s.inWidth+c-n)/o);for(let m=0;m<s.outChannels;++m){const k=Math.trunc(m/p),g=m%p;let I=0;for(let l=0;l<s.batchSize;++l)for(let s=t;s<a;++s){const t=e+s*r-u;for(let e=i;e<d;++e){const a=n+e*o-c;I+=h.get(l,t,a,k)*f.get(l,s,e,m)}}l.set(I,e,n,k,g)}}}return l.toTensor()}tile(e,t){return n(e,"tile"),o(this.bufferSync(e),t)}gather(e,a,s){n([e,a],"gather");const r=e.shape.slice(),o=this.readSync(a.dataId);r[s]=o.length;const i=t.buffer(r,e.dtype),d=this.bufferSync(e);for(let e=0;e<i.size;++e){const t=i.indexToLoc(e),a=t.slice();a[s]=o[t[s]];const n=d.locToIndex(a);i.values[e]=d.values[n]}return i.toTensor()}batchToSpaceND(e,a,s){n([e],"batchToSpaceND");const r=a.reduce((e,t)=>e*t),o=t.backend_util.getReshaped(e.shape,a,r),i=t.backend_util.getPermuted(o.length,a.length),d=t.backend_util.getReshapedPermuted(e.shape,a,r),l=t.backend_util.getSliceBeginCoords(s,a.length),c=t.backend_util.getSliceSize(d,s,a.length);return t.transpose(e.reshape(o),i).reshape(d).slice(l,c)}pool3d(e,a,s){n(e,"pool3d");const r=a.strideDepth,o=a.strideHeight,i=a.strideWidth,d=a.dilationDepth,l=a.dilationHeight,c=a.dilationWidth,u=a.effectiveFilterDepth,p=a.effectiveFilterHeight,h=a.effectiveFilterWidth,f=a.padInfo.front,m=a.padInfo.top,k=a.padInfo.left,g="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,I=this.readSync(e.dataId),b=t.buffer(a.outShape,e.dtype),y=b.values,S=a.outShape[1]*a.outShape[2]*a.outShape[3]*a.outShape[4],T=a.outShape[2]*a.outShape[3]*a.outShape[4],N=a.outShape[3]*a.outShape[4],x=a.outShape[4];for(let t=0;t<a.batchSize;++t){const n=t*S,b=t*e.strides[0];for(let t=0;t<a.inChannels;++t)for(let S=0;S<a.outDepth;++S){const M=S*r-f;let F=M;for(;F<0;)F+=d;const v=Math.min(a.inDepth,u+M),A=n+S*T;for(let n=0;n<a.outHeight;++n){const r=n*o-m;let u=r;for(;u<0;)u+=l;const f=Math.min(a.inHeight,p+r),S=A+n*N;for(let n=0;n<a.outWidth;++n){const r=n*i-k;let o=r;for(;o<0;)o+=c;const p=Math.min(a.inWidth,h+r),m=S+n*x;let T=g,N=0,M=0;for(let a=F;a<v;a+=d){const n=b+a*e.strides[1];for(let a=u;a<f;a+=l){const r=n+a*e.strides[2];for(let a=o;a<p;a+=c){const n=I[r+a*e.strides[3]+t];if("max"===s&&n>T?T=n:"avg"===s&&(N+=n,M++),isNaN(T))break}if(isNaN(T))break}if(isNaN(T))break}y[m+t]="avg"===s?N/M:T}}}}return b.toTensor()}avgPool3d(e,t){return n(e,"avgPool3d"),this.pool3d(e,t,"avg").toFloat()}avgPool3dBackprop(e,a,s){n([e,a],"avgPool3dBackprop");const r=s.strideDepth,o=s.strideHeight,i=s.strideWidth,d=s.filterDepth,l=s.filterHeight,c=s.filterWidth,u=s.dilationDepth,p=s.dilationHeight,h=s.dilationWidth,f=s.effectiveFilterDepth,m=s.effectiveFilterHeight,k=s.effectiveFilterWidth,g=f-1-s.padInfo.front,I=k-1-s.padInfo.left,b=m-1-s.padInfo.top,y=t.buffer(a.shape,"float32"),S=1/(d*l*c),T=this.bufferSync(e);for(let e=0;e<s.batchSize;++e)for(let t=0;t<s.inChannels;++t)for(let a=0;a<s.inDepth;++a)for(let n=0;n<s.inHeight;++n)for(let d=0;d<s.inWidth;++d){const l=a-g,c=n-b,N=d-I;let x=0;for(let a=0;a<f;a+=u){const n=(l+a)/r;if(!(n<0||n>=s.outDepth||Math.floor(n)!==n))for(let a=0;a<m;a+=p){const r=(c+a)/o;if(!(r<0||r>=s.outHeight||Math.floor(r)!==r))for(let a=0;a<k;a+=h){const o=(N+a)/i;o<0||o>=s.outWidth||Math.floor(o)!==o||(x+=T.get(e,n,r,o,t))}}}y.set(x*S,e,a,n,d,t)}return y.toTensor()}maxPool3d(e,t){return n(e,"maxPool3d"),this.pool3d(e,t,"max").toFloat()}maxPool3dPositions(e,a){const n=t.buffer(a.outShape,"int32"),s=a.strideDepth,r=a.strideHeight,o=a.strideWidth,i=a.dilationDepth,d=a.dilationHeight,l=a.dilationWidth,c=a.effectiveFilterDepth,u=a.effectiveFilterHeight,p=a.effectiveFilterWidth,h=a.padInfo.front,f=a.padInfo.top,m=a.padInfo.left,k=this.bufferSync(e);for(let e=0;e<a.batchSize;++e)for(let t=0;t<a.inChannels;++t)for(let g=0;g<a.outDepth;++g){const I=g*s-h;let b=I;for(;b<0;)b+=i;const y=Math.min(a.inDepth,c+I);for(let s=0;s<a.outHeight;++s){const c=s*r-f;let h=c;for(;h<0;)h+=d;const S=Math.min(a.inHeight,u+c);for(let r=0;r<a.outWidth;++r){const f=r*o-m;let T=f;for(;T<0;)T+=l;const N=Math.min(a.inWidth,p+f);let x=Number.NEGATIVE_INFINITY,M=-1;for(let a=b;a<y;a+=i){const n=a-I;for(let s=h;s<S;s+=d){const r=s-c;for(let o=T;o<N;o+=l){const i=o-f,d=k.get(e,a,s,o,t);d>=x&&(x=d,M=n*u*p+r*u+i)}}}n.set(M,e,g,s,r,t)}}}return n.toTensor()}maxPool3dBackprop(e,a,s,r){n([a,s],"maxPool3dBackprop");const o=this.maxPool3dPositions(a,r),i=r.strideDepth,d=r.strideHeight,l=r.strideWidth,c=r.dilationDepth,u=r.dilationHeight,p=r.dilationWidth,h=r.effectiveFilterDepth,f=r.effectiveFilterHeight,m=r.effectiveFilterWidth,k=h-1-r.padInfo.front,g=m-1-r.padInfo.left,I=f-1-r.padInfo.top,b=t.buffer(a.shape,"float32"),y=this.bufferSync(o),S=this.bufferSync(e);for(let e=0;e<r.batchSize;++e)for(let t=0;t<r.inChannels;++t)for(let a=0;a<r.inDepth;++a)for(let n=0;n<r.inHeight;++n)for(let s=0;s<r.inWidth;++s){const o=a-k,T=n-I,N=s-g;let x=0;for(let a=0;a<h;a+=c){const n=(o+a)/i;if(!(n<0||n>=r.outDepth||Math.floor(n)!==n))for(let s=0;s<f;s+=u){const o=(T+s)/d;if(!(o<0||o>=r.outHeight||Math.floor(o)!==o))for(let i=0;i<m;i+=p){const d=(N+i)/l;if(d<0||d>=r.outWidth||Math.floor(d)!==d)continue;const c=h*f*m-1-y.get(e,n,o,d,t)===a*f*m+s*m+i?1:0;0!==c&&(x+=S.get(e,n,o,d,t)*c)}}}b.set(x,e,a,n,s,t)}return b.toTensor()}resizeBilinear(e,a,s,r){n(e,"resizeBilinear");const[o,i,d,l]=e.shape,c=this.readSync(e.dataId),u=new Float32Array(t.util.sizeFromShape([o,a,s,l])),p=[r&&a>1?i-1:i,r&&s>1?d-1:d],h=[r&&a>1?a-1:a,r&&s>1?s-1:s];let f=0;const m=p[0]/h[0],k=p[1]/h[1];for(let t=0;t<o;t++)for(let n=0;n<a;n++){const a=m*n,r=Math.floor(a),o=a-r,p=Math.min(i-1,Math.ceil(a)),h=t*e.strides[0]+r*e.strides[1],g=t*e.strides[0]+p*e.strides[1];for(let t=0;t<s;t++){const a=k*t,n=Math.floor(a),s=a-n,r=Math.min(d-1,Math.ceil(a)),i=h+n*e.strides[2],p=g+n*e.strides[2],m=h+r*e.strides[2],I=g+r*e.strides[2];for(let e=0;e<l;e++){const t=c[i+e],a=c[p+e],n=t+(c[m+e]-t)*s,r=n+(a+(c[I+e]-a)*s-n)*o;u[f++]=r}}}return t.tensor(u,[o,a,s,l])}resizeBilinearBackprop(e,a,s){n([e,a],"resizeBilinearBackprop");const[r,o,i,d]=a.shape,[,l,c]=e.shape,u=new Float32Array(r*o*i*d),p=[s&&l>1?o-1:o,s&&c>1?i-1:i],h=[s&&l>1?l-1:l,s&&c>1?c-1:c],f=p[0]/h[0],m=p[1]/h[1],k=this.readSync(e.dataId);let g=0;for(let e=0;e<r;e++){const t=e*a.strides[0];for(let e=0;e<l;e++){const n=e*f,s=Math.floor(n),r=Math.min(Math.ceil(n),o-1),l=t+s*a.strides[1],p=t+r*a.strides[1],h=n-s,I=1-h;for(let e=0;e<c;e++){const t=e*m,n=Math.floor(t),s=Math.min(Math.ceil(t),i-1),r=t-n,o=1-r,c=l+n*a.strides[2],f=l+s*a.strides[2],b=p+n*a.strides[2],y=p+s*a.strides[2],S=I*o,T=I*r,N=h*o,x=h*r;for(let e=0;e<d;e++){const t=k[g++];u[c+e]+=t*S,u[f+e]+=t*T,u[b+e]+=t*N,u[y+e]+=t*x}}}}return t.tensor4d(u,[r,i,o,d],a.dtype)}resizeNearestNeighbor(e,a,s,r){n(e,"resizeNearestNeighbor");const[o,i,d,l]=e.shape,c=this.readSync(e.dataId),u=new Float32Array(o*a*s*l),p=[r&&a>1?i-1:i,r&&s>1?d-1:d],h=[r&&a>1?a-1:a,r&&s>1?s-1:s],f=p[0]/h[0],m=p[1]/h[1];let k=0;for(let t=0;t<o;t++){const n=t*e.strides[0];for(let t=0;t<a;t++){const a=f*t,o=n+Math.min(i-1,r?Math.round(a):Math.floor(a))*e.strides[1];for(let t=0;t<s;t++){const a=m*t,n=o+Math.min(d-1,r?Math.round(a):Math.floor(a))*e.strides[2];for(let e=0;e<l;e++){const t=c[n+e];u[k++]=t}}}}return t.tensor(u,[o,a,s,l],e.dtype)}resizeNearestNeighborBackprop(e,a,s){n([e,a],"resizeNearestNeighborBackprop");const[r,o,i,d]=a.shape,[,l,c]=e.shape,u=new Float32Array(r*o*i*d),p=this.readSync(e.dataId),h=[s&&l>1?o-1:o,s&&c>1?i-1:i],f=[s&&l>1?l-1:l,s&&c>1?c-1:c],m=h[0]/f[0],k=h[1]/f[1],g=1/m,I=1/k,b=2*Math.ceil(g)+2,y=2*Math.ceil(I)+2;for(let t=0;t<r;t++){const n=t*a.strides[0];for(let t=0;t<o;t++){const r=n+t*a.strides[1],h=Math.floor(t*g),f=Math.floor(h-b/2);for(let h=0;h<i;h++){const g=r+h*a.strides[2],S=Math.floor(h*I),T=Math.floor(S-y/2);for(let a=0;a<d;a++){let r=0;for(let d=0;d<b;d++){const u=d+f;if(u<0||u>=l)continue;const g=n+u*e.strides[1],I=u*m;if(t===Math.min(o-1,s?Math.round(I):Math.floor(I)))for(let t=0;t<y;t++){const n=t+T;if(n<0||n>=c)continue;const o=g+n*e.strides[2],d=n*k;h===Math.min(i-1,s?Math.round(d):Math.floor(d))&&(r+=p[o+a])}}u[g+a]=r}}}}return t.tensor4d(u,a.shape,a.dtype)}localResponseNormalization4D(e,a,s,r,o){n(e,"localResponseNormalization4D");const i=e.shape[3],d=i-1,l=this.readSync(e.dataId),c=e.size,u=new Float32Array(c);function p(e){const t=e%i;let n=e-t+Math.max(0,t-a);const s=e-t+Math.min(t+a,d);let r=0;for(;n<=s;n++){const e=l[n];r+=e*e}return r}for(let e=0;e<c;e++){const t=p(e),a=l[e]*Math.pow(s+r*t,-o);u[e]=a}return t.tensor4d(u,e.shape)}LRNGrad(e,a,s,r,o,i,d){n(e,"LRNGrad");const l=e.shape[3],c=this.readSync(e.dataId),u=this.readSync(a.dataId),p=this.readSync(s.dataId),h=new Float32Array(e.size),f=e.size;for(let e=0;e<f;e++){const t=e%l,a=e-t+Math.max(0,t-r),n=e-t+Math.min(l,t+r+1);let s=0;for(let e=a;e<n;e++)s+=Math.pow(u[e],2);s=i*s+o;for(let t=a;t<n;t++){let a=-2*i*d*u[t]*p[e]/s;e===t&&(a+=Math.pow(s,-d)),a*=c[e],h[t]+=a}}return t.tensor4d(h,e.shape)}multinomial(e,s,r,o){n(e,"multinomial");const i=s?e:t.softmax(e),d=i.shape[0],l=i.shape[1],c=t.zeros([d,r],"int32"),u=this.readSync(c.dataId),p=this.readSync(i.dataId);for(let e=0;e<d;++e){const t=e*l,n=new Float32Array(l-1);n[0]=p[t];for(let e=1;e<n.length;++e)n[e]=n[e-1]+p[t+e];const s=a.alea(o.toString()),i=e*r;for(let e=0;e<r;++e){const t=s();u[i+e]=n.length;for(let a=0;a<n.length;a++)if(t<n[a]){u[i+e]=a;break}}}return c}oneHot(e,a,s,r){n(e,"oneHot");const o=new Float32Array(e.size*a);o.fill(r);const i=this.readSync(e.dataId);for(let t=0;t<e.size;++t)i[t]>=0&&i[t]<a&&(o[t*a+i[t]]=s);return t.tensor2d(o,[e.size,a],"int32")}nonMaxSuppression(e,t,a,r,o){n(e,"nonMaxSuppression");const i=this.readSync(e.dataId),d=this.readSync(t.dataId);return s(i,d,a,r,o)}depthToSpace(e,a,n){t.util.assert("NHWC"===n,()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${n}`),t.util.assert(a>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${a}`);const s=e.shape[0],r=e.shape[1],o=e.shape[2],i=e.shape[3],d=r*a,l=o*a,c=i/(a*a),u=this.readSync(e.dataId),p=new Float32Array(s*d*l*c);let h=0;for(let e=0;e<s;++e)for(let t=0;t<d;++t){const n=Math.floor(t/a),s=t%a;for(let t=0;t<l;++t){const d=Math.floor(t/a),l=(s*a+t%a)*c;for(let t=0;t<c;++t){const a=t+l+i*(d+o*(n+r*e));p[h++]=u[a]}}}return t.tensor4d(p,[s,d,l,c])}broadcastedBinaryOp(e,a,n,s){const r=t.backend_util.assertAndGetBroadcastShape(e.shape,a.shape),o=t.buffer(r,n),i=this.readSync(e.dataId),d=this.readSync(a.dataId),l=t.backend_util.getBroadcastDims(e.shape,r),c=t.backend_util.getBroadcastDims(a.shape,r),u=o.values;if(l.length+c.length===0)for(let e=0;e<u.length;++e)u[e]=s(i[e%i.length],d[e%d.length]);else{const t=this.bufferSync(e),n=this.bufferSync(a);for(let r=0;r<u.length;++r){const p=o.indexToLoc(r),h=p.slice(-e.rank);l.forEach(e=>h[e]=0);const f=t.locToIndex(h),m=p.slice(-a.rank);c.forEach(e=>m[e]=0);const k=n.locToIndex(m);u[r]=s(i[f],d[k])}}return o.toTensor()}split(e,t,a){return r(e,t,a)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}cropAndResize(e,a,n,s,r,o){const[i,d,l,c]=e.shape,u=a.shape[0],[p,h]=s,f=t.buffer([u,p,h,c],"float32"),m=this.readSync(a.dataId),k=this.readSync(n.dataId),g=this.readSync(e.dataId),I=e.strides,b=f.strides;for(let e=0;e<u;e++){const t=4*e,a=m[t],n=m[t+1],s=m[t+2],u=m[t+3],y=k[e];if(y>=i)continue;const S=p>1?(s-a)*(d-1)/(p-1):0,T=h>1?(u-n)*(l-1)/(h-1):0;for(let t=0;t<p;t++){const i=p>1?a*(d-1)+t*S:.5*(a+s)*(d-1);if(i<0||i>d-1)for(let a=0;a<h;a++)for(let n=0;n<c;n++){const s=n+a*b[2]+t*b[1]+e*b[0];f.values[s]=o}else if("bilinear"===r){const a=Math.floor(i),s=Math.ceil(i),r=i-a;for(let i=0;i<h;i++){const d=h>1?n*(l-1)+i*T:.5*(n+u)*(l-1);if(d<0||d>l-1){for(let a=0;a<c;a++){const n=a+i*b[2]+t*b[1]+e*b[0];f.values[n]=o}continue}const p=Math.floor(d),m=Math.ceil(d),k=d-p;for(let n=0;n<c;n++){let o=n+p*I[2]+a*I[1]+y*I[0];const d=g[o];o=n+m*I[2]+a*I[1]+y*I[0];const l=g[o];o=n+p*I[2]+s*I[1]+y*I[0];const c=g[o];o=n+m*I[2]+s*I[1]+y*I[0];const u=d+(l-d)*k,h=c+(g[o]-c)*k;o=n+i*b[2]+t*b[1]+e*b[0],f.values[o]=u+(h-u)*r}}}else for(let a=0;a<h;++a){const s=h>1?n*(l-1)+a*T:.5*(n+u)*(l-1);if(s<0||s>l-1){for(let n=0;n<c;n++){const s=n+a*b[2]+t*b[1]+e*b[0];f.values[s]=o}continue}const r=Math.round(s),d=Math.round(i);for(let n=0;n<c;n++){const s=n+r*I[2]+d*I[1]+y*I[0],o=n+a*b[2]+t*b[1]+e*b[0];f.values[o]=g[s]}}}}return f.toTensor()}sparseToDense(e,a,n,s){const{sliceRank:r,numUpdates:o,sliceSize:i,strides:d,outputSize:l}=t.backend_util.calculateShapes(a,e,n);return this.scatter(e,a,n,l,i,o,r,d,s,!1)}gatherND(e,a){const n=a.shape,s=n[n.length-1],[r,o,i,d]=t.backend_util.prepareAndValidate(e,a);if(0===o)return t.tensor([],r,e.dtype);const l=new t.TensorBuffer([o,i],e.dtype),c=this.readSync(a.dataId),u=this.readSync(e.dataId);for(let t=0;t<o;t++){const a=[];let n=0;for(let e=0;e<s;e++){const r=c[t*s+e];n+=r*d[e],a.push(r)}if(n<0||n>=e.size/i)throw new Error(`Invalid indices: ${a} does not index into ${e.shape}`);for(let e=0;e<i;e++)l.values[t*i+e]=u[n*i+e]}return l.toTensor().reshape(r)}scatterND(e,a,n){const{sliceRank:s,numUpdates:r,sliceSize:o,strides:i,outputSize:d}=t.backend_util.calculateShapes(a,e,n),l=t.scalar(0);return this.scatter(e,a,n,d,o,r,s,i,l,!0)}fill(e,a,n){n=n||t.util.inferDtype(a);const s=t.util.getArrayFromDType(n,t.util.sizeFromShape(e));return s.fill(a),t.engine().makeTensor(s,e,n,this)}onesLike(e){if("string"===e.dtype)throw new Error("onesLike is not supported for string tensors");return this.fill(e.shape,1,e.dtype)}zerosLike(e){const a=t.util.getArrayFromDType(e.dtype,t.util.sizeFromShape(e.shape));return this.makeOutput(a,e.shape,e.dtype)}linspace(e,a,n){return t.backend_util.linspaceImpl(e,a,n)}scatter(e,a,n,s,r,o,i,d,l,c){const u=[s/r,r],p=this.readSync(e.dataId),h=this.readSync(a.dataId);if(0===s)return t.tensor([],n,a.dtype);const f=new t.TensorBuffer(u,a.dtype);f.values.fill(this.readSync(l.dataId)[0]);for(let e=0;e<o;e++){const t=[];let o=0;for(let a=0;a<i;a++){const n=p[e*i+a];t.push(n),o+=n*d[a]}if(o<0||o>=s/r)throw new Error(`Invalid indices: ${t} does not index into ${n}`);for(let t=0;t<r;t++)c?f.values[o*r+t]+=h[e*r+t]:f.values[o*r+t]=0===a.rank?h[0]:h[e*r+t]}return f.toTensor().reshape(n)}}function u(e){const t=new Float32Array(e.length);for(let a=0;a<e.length;++a)t[a]=Math.abs(e[a]);return t}const p={kernelName:t.Abs,backendName:"cpu",kernelFunc:e=>{const{x:a}=e.inputs,n=e.backend;let s=new Float32Array(t.util.sizeFromShape(a.shape));if("complex64"!==a.dtype){s=u(n.data.get(a.dataId).values)}else{const e=n.data.get(a.dataId),t=e.complexTensorInfos.real,r=e.complexTensorInfos.imag,o=n.data.get(t.dataId).values,i=n.data.get(r.dataId).values;for(let e=0;e<o.length;e++){const t=o[e],a=i[e];s[e]=Math.hypot(t,a)}}return n.makeOutput(s,a.shape,"float32")}};function h(e){return(a,n,s,r,o)=>{const i=t.backend_util.assertAndGetBroadcastShape(a,n),d=i.length,l=t.util.computeStrides(i),c=t.util.sizeFromShape(i),u=t.util.getTypedArrayFromDType(o,c),p=a.length,h=n.length,f=t.util.computeStrides(a),m=t.util.computeStrides(n),k=t.backend_util.getBroadcastDims(a,i),g=t.backend_util.getBroadcastDims(n,i);if(k.length+g.length===0)for(let t=0;t<u.length;++t)u[t]=e(s[t%s.length],r[t%r.length]);else for(let a=0;a<u.length;++a){const n=t.util.indexToLoc(a,d,l),o=n.slice(-p);k.forEach(e=>o[e]=0);const i=t.util.locToIndex(o,p,f),c=n.slice(-h);g.forEach(e=>c[e]=0);const I=t.util.locToIndex(c,h,m);u[a]=e(s[i],r[I])}return[u,i]}}function f(e){const{inputs:t,backend:a}=e,{real:n,imag:s}=t,r=a.data.get(n.dataId).values,o=a.data.get(s.dataId).values,i=a.makeTensorInfo(n.shape,"complex64");return a.data.get(i.dataId).complexTensorInfos={real:a.makeTensorInfo(n.shape,"float32",r),imag:a.makeTensorInfo(s.shape,"float32",o)},i}const m={kernelName:t.Complex,backendName:"cpu",kernelFunc:f};function k(e){const{inputs:t,backend:a}=e,{x:n}=t;return a.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}const g={kernelName:t.Identity,backendName:"cpu",kernelFunc:k};function I(e){const{inputs:t,backend:a}=e,{input:n}=t,s=a.data.get(n.dataId).complexTensorInfos.real,r=a.data.get(s.dataId).values;return a.makeTensorInfo(s.shape,s.dtype,r)}const b={kernelName:t.Real,backendName:"cpu",kernelFunc:I};function y(e){const{inputs:a,backend:n,attrs:s}=e,{x:r}=a,{dtype:o}=s;if("complex64"===o){if("complex64"===r.dtype)return k({inputs:{x:r},backend:n});const e=t.zeros(r.shape),a=y({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),s=f({inputs:{real:a,imag:e},backend:n});return e.dispose(),n.disposeIntermediateTensorInfo(a),s}if("complex64"===r.dtype){const e=I({inputs:{input:r},backend:n}),t=y({inputs:{x:e},backend:n,attrs:{dtype:o}});return n.disposeIntermediateTensorInfo(e),t}if(!t.util.hasEncodingLoss(r.dtype,o)){const e=k({inputs:{x:r},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:o}}if("int32"===o){const e=n.data.get(r.dataId).values,t=Int32Array.from(e);return n.makeTensorInfo(r.shape,"int32",t)}if("bool"===o){const e=n.data.get(r.dataId).values,a=t.util.toTypedArray([0],r.dtype),[s,o]=h((e,t)=>e!==t?1:0)(r.shape,[],e,a,"bool");return n.makeTensorInfo(o,"bool",s)}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${o}`)}const S={kernelName:t.Cast,backendName:"cpu",kernelFunc:y};function T(e,t,a,s){return null==a?({inputs:a,backend:r})=>{const{a:o,b:i}=a,d=r;n([o,i],e);const l=d.data.get(o.dataId).values,c=d.data.get(i.dataId).values,u=s||o.dtype,[p,h]=t(o.shape,i.shape,l,c,u);return d.makeTensorInfo(h,u,p)}:({inputs:e,backend:n})=>{const{a:r,b:o}=e,i=n;if("complex64"===r.dtype||"complex64"===o.dtype){const e=y({inputs:{x:r},backend:i,attrs:{dtype:"complex64"}}),t=i.data.get(e.dataId),n=t.complexTensorInfos.real,s=t.complexTensorInfos.imag,d=i.data.get(n.dataId).values,l=i.data.get(s.dataId).values,c=y({inputs:{x:o},backend:i,attrs:{dtype:"complex64"}}),u=i.data.get(c.dataId),p=u.complexTensorInfos.real,h=u.complexTensorInfos.imag,m=i.data.get(p.dataId).values,k=i.data.get(h.dataId).values,[g,I,b]=a(r.shape,o.shape,d,l,m,k),S=i.makeTensorInfo(b,"float32",g),T=i.makeTensorInfo(b,"float32",I),N=f({inputs:{real:S,imag:T},backend:i});return i.disposeIntermediateTensorInfo(e),i.disposeIntermediateTensorInfo(c),i.disposeIntermediateTensorInfo(S),i.disposeIntermediateTensorInfo(T),N}{const e=i.data.get(r.dataId).values,a=i.data.get(o.dataId).values,n=s||r.dtype,[d,l]=t(r.shape,o.shape,e,a,n);return i.makeTensorInfo(l,n,d)}}}function N(e){return(a,n,s,r,o,i)=>{const d=t.backend_util.assertAndGetBroadcastShape(a,n),l=t.util.sizeFromShape(d),c=d.length,u=t.util.computeStrides(d),p=t.util.getTypedArrayFromDType("float32",l),h=t.util.getTypedArrayFromDType("float32",l),f=t.backend_util.getBroadcastDims(a,d),m=t.backend_util.getBroadcastDims(n,d),k=t.backend_util.mergeRealAndImagArrays(s,r),g=t.backend_util.mergeRealAndImagArrays(o,i),I=a.length,b=t.util.computeStrides(a),y=n.length,S=t.util.computeStrides(n);if(f.length+m.length===0)for(let t=0;t<p.length;t++){const a=t%k.length,n=t%g.length,s=e(k[2*a],k[2*a+1],g[2*n],g[2*n+1]);p[t]=s.real,h[t]=s.imag}else for(let a=0;a<p.length;a++){const n=t.util.indexToLoc(a,c,u),s=n.slice(-I);f.forEach(e=>s[e]=0);const r=t.util.locToIndex(s,I,b),o=n.slice(-y);m.forEach(e=>o[e]=0);const i=t.util.locToIndex(o,y,S),d=e(k[2*r],k[2*r+1],g[2*i],g[2*i+1]);p[a]=d.real,h[a]=d.imag}return[p,h,d]}}const x=h((e,t)=>e+t),M=N((e,t,a,n)=>({real:e+a,imag:t+n})),F=T(t.Add,x,M),v={kernelName:t.Add,backendName:"cpu",kernelFunc:F};function A(e){return(a,n,s)=>{const r=t.util.getTypedArrayFromDType(n,a.length);for(let t=0;t<a.length;++t)r[t]=e(a[t],s);return r}}function D(e,a,s){return({inputs:r,attrs:o,backend:i})=>{const{x:d}=r;if(n(d,e),"string"===d.dtype||"string"===s)throw new Error("unaryKernelFunc does not support string input/output");const l=i,c=l.data.get(d.dataId).values,u=t.util.sizeFromShape(d.shape),p=s||d.dtype,h=t.util.getArrayFromDType(p,u);for(let e=0;e<u;++e)h[e]=a(c[e],o);return l.makeTensorInfo(d.shape,p,h)}}function z(e,t,a){return({inputs:s,attrs:r,backend:o})=>{const{x:i}=s;if(n(i,e),"string"===i.dtype||"string"===a)throw new Error("unaryKernelFunc does not support string input/output");const d=o,l=d.data.get(i.dataId).values,c=a||i.dtype,u=t(l,c,r);return d.makeTensorInfo(i.shape,c,u)}}const _=A(e=>Math.ceil(e)),W=z(t.Ceil,_),H={kernelName:t.Ceil,backendName:"cpu",kernelFunc:W},w=A(e=>Math.exp(e)),C=z(t.Exp,w),E={kernelName:t.Exp,backendName:"cpu",kernelFunc:C},B=A(e=>Math.expm1(e)),O=z(t.Expm1,B),P={kernelName:t.Expm1,backendName:"cpu",kernelFunc:O},R=A(e=>Math.floor(e)),q=z(t.Floor,R),L={kernelName:t.Floor,backendName:"cpu",kernelFunc:q},V=A(e=>Math.log(e)),$=z(t.Log,V),G={kernelName:t.Log,backendName:"cpu",kernelFunc:$};function U(e,a,n,s){const r=t.util.getTypedArrayFromDType(s,t.util.sizeFromShape(n));for(let t=0;t<r.length;++t){const n=t*a;let s=e[n];for(let t=0;t<a;++t){const a=e[n+t];a>s&&(s=a)}r[t]=s}return r}const j=h((e,t)=>e*t),K=N((e,t,a,n)=>({real:e*a-t*n,imag:e*n+t*a})),Y=T(t.Multiply,j,K),Z={kernelName:t.Multiply,backendName:"cpu",kernelFunc:Y},J=A(e=>1/Math.sqrt(e)),Q=z(t.Rsqrt,J),X={kernelName:t.Rsqrt,backendName:"cpu",kernelFunc:Q};function ee(e,a,n,s,r){const o=t.slice_util.isSliceContinous(s,a,n),i=t.util.sizeFromShape(n),d=t.util.computeStrides(s);if(o){const n=t.slice_util.computeFlatOffset(a,d);return e.subarray(n,n+i)}const l=t.util.getTypedArrayFromDType(r,i);for(let r=0;r<i;++r){const o=n.length,i=t.util.computeStrides(n),c=t.util.indexToLoc(r,o,i).map((e,t)=>e+a[t]),u=t.util.locToIndex(c,s.length,d);l[r]=e[u]}return l}function te(e){const{inputs:a,backend:s,attrs:r}=e,{x:o}=a,{begin:i,size:d}=r;n(o,"slice");const[l,c]=t.slice_util.parseSliceParams(o,i,d);t.slice_util.assertParamsValid(o,l,c);const u=ee(s.data.get(o.dataId).values,l,c,o.shape,o.dtype);return s.makeTensorInfo(c,o.dtype,u)}const ae={kernelName:t.Slice,backendName:"cpu",kernelFunc:te},ne=h((e,t)=>e-t),se=N((e,t,a,n)=>({real:e-a,imag:t-n})),re=T(t.Sub,ne,se),oe={kernelName:t.Sub,backendName:"cpu",kernelFunc:re};function ie(e,a,n,s,r){const o=a.length,i=t.util.sizeFromShape(a),d=t.util.computeStrides(a),l=t.util.computeStrides(r),c=t.util.getTypedArrayFromDType(n,t.util.sizeFromShape(r));for(let a=0;a<i;++a){const n=t.util.indexToLoc(a,o,d),r=new Array(n.length);for(let e=0;e<r.length;e++)r[e]=n[s[e]];c[t.util.locToIndex(r,o,l)]=e[a]}return c}function de(e,a,n,s){const r=t.util.parseAxisParam(a,n)[0],o=[1,n[0],1];for(let e=0;e<r;e++)o[0]*=n[e];o[1]=n[r];for(let e=r+1;e<n.length;e++)o[2]*=n[e];const i={},d=new Int32Array(n[r]),l=new t.TensorBuffer(o,s,e),c=[],u=1===o[0]&&1===o[2];for(let t=0;t<n[r];t++){let a;if(u)a=e[t].toString();else{const e=[];for(let a=0;a<o[0];a++)for(let n=0;n<o[2];n++)e.push(l.get(a,t,n));a=e.join(",")}if(void 0!==i[a])d[t]=i[a];else{const e=Object.keys(i).length;i[a]=e,d[t]=e,c.push(t)}}const p=o.slice();p[1]=Object.keys(i).length;const h=new t.TensorBuffer(p,s);c.forEach((e,t)=>{for(let a=0;a<o[0];a++)for(let n=0;n<o[2];n++)h.set(l.get(a,e,n),a,t,n)});const f=n.slice();return f[r]=p[1],{outputValues:h.values,outputShape:f,indices:d}}var le=Object.freeze({__proto__:null,simpleAbsImpl:u,addImpl:x,ceilImpl:_,expImpl:w,expm1Impl:B,floorImpl:R,logImpl:V,maxImpl:U,multiplyImpl:j,rsqrtImpl:J,sliceImpl:ee,subImpl:ne,transposeImpl:ie,uniqueImpl:de});t.registerBackend("cpu",()=>new c,1);const ce=D(t.Acos,e=>Math.acos(e)),ue={kernelName:t.Acos,backendName:"cpu",kernelFunc:ce},pe=D(t.Acosh,e=>Math.acosh(e)),he={kernelName:t.Acosh,backendName:"cpu",kernelFunc:pe},fe=D(t.Asin,e=>Math.asin(e)),me={kernelName:t.Asin,backendName:"cpu",kernelFunc:fe},ke=D(t.Asinh,e=>Math.asinh(e)),ge={kernelName:t.Asinh,backendName:"cpu",kernelFunc:ke},Ie=D(t.Atan,e=>Math.atan(e)),be={kernelName:t.Atan,backendName:"cpu",kernelFunc:Ie},ye=D(t.Atanh,e=>Math.atanh(e)),Se={kernelName:t.Atanh,backendName:"cpu",kernelFunc:ye};function Te(e,a,n,s,r,o){const i=r.strideHeight,d=r.strideWidth,l=r.dilationHeight,c=r.dilationWidth,u=r.effectiveFilterHeight,p=r.effectiveFilterWidth,h=r.padInfo.top,f=r.padInfo.left,m="max"===o?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,k=t.buffer(r.outShape,n),g=k.values,I=r.outShape[1]*r.outShape[2]*r.outShape[3],b=r.outShape[2]*r.outShape[3],y=r.outShape[3];for(let t=0;t<r.batchSize;++t){const a=t*I,n=t*s[0];for(let t=0;t<r.inChannels;++t)for(let k=0;k<r.outHeight;++k){const I=k*i-h,S=Math.max(0,I),T=Math.min(r.inHeight,u+I),N=a+k*b;for(let a=0;a<r.outWidth;++a){const i=a*d-f,u=Math.max(0,i),h=Math.min(r.inWidth,p+i);let k=m,I=0,b=0;for(let a=S;a<T;a+=l){const r=n+a*s[1];for(let a=u;a<h;a+=c){const n=e[r+a*s[2]+t];"max"===o&&n>k?k=n:"avg"===o&&(I+=n,b++)}if(isNaN(k))break}g[N+a*y+t]="avg"===o?I/b:k}}}return k}function Ne(e,a,n,s,r=!1,o=!1){const i=t.buffer(s.outShape,"int32"),d=s.strideHeight,l=s.strideWidth,c=s.dilationHeight,u=s.dilationWidth,p=s.effectiveFilterHeight,h=s.effectiveFilterWidth,f=s.padInfo.top,m=s.padInfo.left,k=t.buffer(a,n,e);for(let e=0;e<s.batchSize;++e)for(let t=0;t<s.inChannels;++t)for(let a=0;a<s.outHeight;++a){const n=a*d-f;let g=n;for(;g<0;)g+=c;const I=Math.min(s.inHeight,p+n);for(let d=0;d<s.outWidth;++d){const p=d*l-m;let f=p;for(;f<0;)f+=u;const b=Math.min(s.inWidth,h+p);let y=Number.NEGATIVE_INFINITY,S=-1;for(let a=g;a<I;a+=c){const i=a-n;for(let n=f;n<b;n+=u){const d=n-p,l=k.get(e,a,n,t);l>y&&(y=l,S=r?o?((e*s.inHeight+a)*s.inWidth+n)*s.inChannels+t:(a*s.inWidth+n)*s.inChannels+t:i*h+d)}}i.set(S,e,a,d,t)}}return i}const xe={kernelName:t.AvgPool,backendName:"cpu",kernelFunc:function(e){const{inputs:a,backend:s,attrs:r}=e,{x:o}=a;n(o,"avgPool");const{filterSize:i,strides:d,pad:l,dimRoundingMode:c}=r;t.util.assert(t.backend_util.eitherStridesOrDilationsAreOne(d,1),()=>"Error in avgPool: Either strides or dilations must be 1. "+`Got strides ${d} and dilations '1'`);const u=t.backend_util.computePool2DInfo(o.shape,i,d,1,l,c);let p;if(1===u.filterWidth&&1===u.filterHeight&&t.util.arraysEqual(u.inShape,u.outShape))p=k({inputs:{x:o},backend:s});else{const e=s.data.get(o.dataId).values,a=t.util.computeStrides(o.shape),n=Te(e,o.shape,o.dtype,a,u,"avg");p=s.makeTensorInfo(u.outShape,o.dtype,n.values)}return p}};const Me={kernelName:t.AvgPoolBackprop,backendName:"cpu",kernelFunc:function(e){const{inputs:a,backend:s,attrs:r}=e,{dy:o,input:i}=a,d=i;n([o,i],"avgPoolBackprop");const{filterSize:l,strides:c,pad:u}=r,p=t.backend_util.computePool2DInfo(d.shape,l,c,1,u),h=p.strideHeight,f=p.strideWidth,m=p.filterHeight,k=p.filterWidth,g=p.dilationHeight,I=p.dilationWidth,b=p.effectiveFilterHeight,y=p.effectiveFilterWidth,S=y-1-p.padInfo.left,T=b-1-p.padInfo.top,N=t.buffer(d.shape,"float32"),x=1/(m*k),M=s.data.get(o.dataId).values,F=t.buffer(o.shape,"float32",M);for(let e=0;e<p.batchSize;++e)for(let t=0;t<p.inChannels;++t)for(let a=0;a<p.inHeight;++a)for(let n=0;n<p.inWidth;++n){const s=a-T,r=n-S;let o=0;for(let a=0;a<b;a+=g){const n=(s+a)/h;if(!(n<0||n>=p.outHeight||Math.floor(n)!==n))for(let a=0;a<y;a+=I){const s=(r+a)/f;s<0||s>=p.outWidth||Math.floor(s)!==s||(o+=F.get(e,n,s,t))}}N.set(o*x,e,a,n,t)}return s.makeTensorInfo(N.shape,N.dtype,N.values)}};const Fe={kernelName:t.FusedBatchNorm,backendName:"cpu",kernelFunc:function(e){const{inputs:a,backend:s,attrs:r}=e,{x:o,scale:i,offset:d,mean:l,variance:c}=a;t.util.assert(l.shape.length===c.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),t.util.assert(null==d||l.shape.length===d.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),t.util.assert(null==i||l.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),n([o,l,c,i,d],"batchNorm");let{varianceEpsilon:u}=r;null==u&&(u=.001);const p=s.data.get(o.dataId).values,h=s.data.get(l.dataId).values,f=s.data.get(c.dataId).values,m=i?s.data.get(i.dataId).values:new Float32Array([1]),k=d?s.data.get(d.dataId).values:new Float32Array([0]),g=new Float32Array(p.length),I=k.length,b=m.length,y=f.length,S=h.length;let T=0,N=0,x=0,M=0;for(let e=0;e<p.length;++e)g[e]=k[T++]+(p[e]-h[N++])*m[x++]/Math.sqrt(f[M++]+u),T>=I&&(T=0),N>=S&&(N=0),x>=b&&(x=0),M>=y&&(M=0);return s.makeTensorInfo(o.shape,o.dtype,g)}},ve=D(t.ClipByValue,(e,t)=>{const a=t;return e>a.clipValueMax?a.clipValueMax:e<a.clipValueMin?a.clipValueMin:e}),Ae={kernelName:t.ClipByValue,backendName:"cpu",kernelFunc:ve};function De(e){const{inputs:t,backend:a}=e,{input:n}=t,s=a.data.get(n.dataId).complexTensorInfos.imag,r=a.data.get(s.dataId).values;return a.makeTensorInfo(s.shape,s.dtype,r)}const ze={kernelName:t.Imag,backendName:"cpu",kernelFunc:De};function _e(e){const{inputs:a,backend:n,attrs:s}=e,{x:r}=a,{shape:o}=s,i=t.util.sizeFromShape(r.shape),d=t.util.inferFromImplicitShape(o,i),l=t.util.sizeFromShape(d);t.util.assert(i===l,()=>`The new shape (${d}) has ${l} elements and the old `+`shape (${r.shape}) has ${i} elements. The new shape and old `+"shape must have the same number of elements."),n.incRef(r.dataId);const c=n.data.get(r.dataId);if(null!=c.complexTensorInfos){const e=c.complexTensorInfos.real,t=c.complexTensorInfos.imag;e.shape=d,t.shape=d}return{dataId:r.dataId,shape:d,dtype:r.dtype}}const We={kernelName:t.Reshape,backendName:"cpu",kernelFunc:_e};function He(e){const{inputs:a,backend:n,attrs:s}=e,{axis:r}=s,o=t.util.parseAxisParam(r,a[0].shape)[0];let i=t.backend_util.computeOutShape(a.map(e=>e.shape),o);if(0===t.util.sizeFromShape(i))return n.makeTensorInfo(i,a[0].dtype,[]);const d=a.filter(e=>t.util.sizeFromShape(e.shape)>0);if(1===d.length)return d[0];const l=d.map(e=>e.shape);if(t.backend_util.assertParamsConsistent(l,o),"complex64"===d[0].dtype){const e=d.map(e=>I({inputs:{input:e},backend:n})),t=d.map(e=>De({inputs:{input:e},backend:n})),a=He({inputs:e,backend:n,attrs:{axis:r}}),s=He({inputs:t,backend:n,attrs:{axis:r}}),o=f({inputs:{real:a,imag:s},backend:n});return e.forEach(e=>n.disposeIntermediateTensorInfo(e)),t.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),o}const c=d.map(e=>{const a=t.util.sizeFromShape(e.shape.slice(o));return _e({inputs:{x:e},backend:n,attrs:{shape:[-1,a]}})});i=t.backend_util.computeOutShape(c.map(e=>e.shape),1);const u=t.util.getTypedArrayFromDType(d[0].dtype,t.util.sizeFromShape(i));if(1===c[0].shape[0]){let e=0;c.forEach(a=>{const s=n.data.get(a.dataId).values,r=t.util.sizeFromShape(a.shape);u.set(s,e),e+=r})}else{let e=0;c.forEach(t=>{const a=n.data.get(t.dataId).values;let s=0;for(let n=0;n<t.shape[0];++n){const r=n*i[1]+e;for(let e=0;e<t.shape[1];++e)u[r+e]=a[s++]}e+=t.shape[1]})}const p=t.backend_util.computeOutShape(d.map(e=>e.shape),o),h=n.makeTensorInfo(p,a[0].dtype,u);return c.forEach(e=>n.disposeIntermediateTensorInfo(e)),h}const we={kernelName:t.Concat,backendName:"cpu",kernelFunc:He},Ce=D(t.Cos,e=>Math.cos(e)),Ee={kernelName:t.Cos,backendName:"cpu",kernelFunc:Ce},Be=D(t.Cosh,e=>Math.cosh(e)),Oe={kernelName:t.Cosh,backendName:"cpu",kernelFunc:Be},Pe={kernelName:t.Dilation2D,backendName:"cpu",kernelFunc:({inputs:e,backend:a,attrs:n})=>{const{x:s,filter:r}=e,{strides:o,pad:i,dilations:d}=n,l=a,c=l.data.get(s.dataId).values,u=s.shape.length,p=l.data.get(r.dataId).values,h=r.shape.length,{batchSize:f,inHeight:m,inWidth:k,inChannels:g,outHeight:I,outWidth:b,padInfo:y,strideHeight:S,strideWidth:T,filterHeight:N,filterWidth:x,dilationHeight:M,dilationWidth:F,outShape:v}=t.backend_util.computeDilation2DInfo(s.shape,r.shape,o,i,"NHWC",d),A=t.util.sizeFromShape(v),D=v.length,z=t.util.getArrayFromDType(s.dtype,A);for(let e=0;e<f;++e)for(let a=0;a<I;++a){const n=a*S-y.top;for(let o=0;o<b;++o){const i=o*T-y.left;for(let d=0;d<g;++d){let l=Number.MIN_SAFE_INTEGER;for(let a=0;a<N;++a){const o=n+a*M;if(o>=0&&o<m)for(let n=0;n<x;++n){const f=i+n*F;if(f>=0&&f<k){const i=t.util.locToIndex([e,o,f,d],u,t.util.computeStrides(s.shape)),m=t.util.locToIndex([a,n,d],h,t.util.computeStrides(r.shape)),k=c[i]+p[m];k>l&&(l=k)}}}z[t.util.locToIndex([e,a,o,d],D,t.util.computeStrides(v))]=l}}}return{dataId:l.write(t.util.toTypedArray(z,s.dtype),v,s.dtype),shape:v,dtype:s.dtype}}},Re={kernelName:t.Dilation2DBackpropFilter,backendName:"cpu",kernelFunc:({inputs:e,backend:a,attrs:n})=>{const{x:s,filter:r,dy:o}=e,{strides:i,pad:d,dilations:l}=n,c=a,u=t.util.toNestedArray(s.shape,c.data.get(s.dataId).values),p=t.util.toNestedArray(r.shape,c.data.get(r.dataId).values),{batchSize:h,inHeight:f,inWidth:m,inChannels:k,outHeight:g,outWidth:I,padInfo:b,strideHeight:y,strideWidth:S,filterHeight:T,filterWidth:N,dilationHeight:x,dilationWidth:M,outShape:F}=t.backend_util.computeDilation2DInfo(s.shape,r.shape,i,d,"NHWC",l);t.util.assert(o.rank===F.length,()=>`Error in ${t.Dilation2DBackpropFilter}, dy `+`must have the same rank as output ${F.length}, but got `+`${o.rank}`);const v=t.util.toNestedArray(F,c.data.get(o.dataId).values),A=t.util.makeZerosNestedTypedArray(r.shape,r.dtype);for(let e=0;e<h;++e)for(let t=0;t<g;++t){const a=t*y-b.top;for(let n=0;n<I;++n){const s=n*S-b.left;for(let r=0;r<k;++r){let o=Number.MIN_SAFE_INTEGER,i=0,d=0;for(let t=0;t<T;++t){const n=a+t*x;if(n>=0&&n<f)for(let a=0;a<N;++a){const l=s+a*M;if(l>=0&&l<m){const s=u[e][n][l][r]+p[t][a][r];s>o&&(o=s,i=t,d=a)}}}A[i][d][r]+=v[e][t][n][r]}}}return{dataId:c.write(t.util.toTypedArray(A,s.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},qe={kernelName:t.Dilation2DBackpropInput,backendName:"cpu",kernelFunc:({inputs:e,backend:a,attrs:n})=>{const{x:s,filter:r,dy:o}=e,{strides:i,pad:d,dilations:l}=n,c=a,u=t.util.toNestedArray(s.shape,c.data.get(s.dataId).values),p=t.util.toNestedArray(r.shape,c.data.get(r.dataId).values),{batchSize:h,inHeight:f,inWidth:m,inChannels:k,outHeight:g,outWidth:I,padInfo:b,strideHeight:y,strideWidth:S,filterHeight:T,filterWidth:N,dilationHeight:x,dilationWidth:M,outShape:F}=t.backend_util.computeDilation2DInfo(s.shape,r.shape,i,d,"NHWC",l);t.util.assert(o.rank===F.length,()=>`Error in ${t.Dilation2DBackpropInput}, dy `+`must have the same rank as output ${F.length}, but got `+`${o.rank}`);const v=t.util.toNestedArray(F,c.data.get(o.dataId).values),A=t.util.makeZerosNestedTypedArray(s.shape,s.dtype);for(let e=0;e<h;++e)for(let t=0;t<g;++t){const a=t*y-b.top;for(let n=0;n<I;++n){const s=n*S-b.left;for(let r=0;r<k;++r){let o=Number.MIN_SAFE_INTEGER,i=a<0?0:a,d=s<0?0:s;for(let t=0;t<T;++t){const n=a+t*x;if(n>=0&&n<f)for(let a=0;a<N;++a){const l=s+a*M;if(l>=0&&l<m){const s=u[e][n][l][r]+p[t][a][r];s>o&&(o=s,i=n,d=l)}}}A[e][i][d][r]+=v[e][t][n][r]}}}return{dataId:c.write(t.util.toTypedArray(A,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},Le=h((e,t)=>e/t),Ve=T(t.Div,Le),$e={kernelName:t.Div,backendName:"cpu",kernelFunc:Ve},Ge=D(t.Elu,e=>e>=0?e:Math.exp(e)-1),Ue={kernelName:t.Elu,backendName:"cpu",kernelFunc:Ge},je=t.backend_util.ERF_P,Ke=t.backend_util.ERF_A1,Ye=t.backend_util.ERF_A2,Ze=t.backend_util.ERF_A3,Je=t.backend_util.ERF_A4,Qe=t.backend_util.ERF_A5,Xe=D(t.Erf,e=>{const t=Math.sign(e),a=Math.abs(e),n=1/(1+je*a);return t*(1-((((Qe*n+Je)*n+Ze)*n+Ye)*n+Ke)*n*Math.exp(-a*a))}),et={kernelName:t.Erf,backendName:"cpu",kernelFunc:Xe};function tt(e,a,n){const s=e.shape,r=s[0],o=s[1],i=n.data.get(e.dataId),d=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,c=[r,o],u=t.util.sizeFromShape(c),p=t.util.getTypedArrayFromDType("float32",u),h=t.util.getTypedArrayFromDType("float32",u);for(let e=0;e<r;e++){const s=te({inputs:{x:d},backend:n,attrs:{begin:[e,0],size:[1,o]}}),r=te({inputs:{x:l},backend:n,attrs:{begin:[e,0],size:[1,o]}}),i=f({inputs:{real:s,imag:r},backend:n}),{real:c,imag:u}=at(i,a,n),m=t.backend_util.mergeRealAndImagArrays(c,u);for(let a=0;a<o;a++){const n=t.backend_util.getComplexWithIndex(m,a);p[e*o+a]=n.real,h[e*o+a]=n.imag}n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(i)}const m=n.makeTensorInfo(c,"float32",p),k=n.makeTensorInfo(c,"float32",h),g=f({inputs:{real:m,imag:k},backend:n});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(k),g}function at(e,a,n){const s=t.util.sizeFromShape(e.shape),r=n.data.get(e.dataId),o=n.data.get(r.complexTensorInfos.real.dataId).values,i=n.data.get(r.complexTensorInfos.imag.dataId).values;if(0==((d=s)&d-1)){const r=function e(a,n,s,r,o){if(1===s)return{real:a,imag:n};const i=t.backend_util.mergeRealAndImagArrays(a,n),d=s/2,l=t.backend_util.complexWithEvenIndex(i),c=l.real,u=l.imag,p=[c.length],h=o.makeTensorInfo(p,"float32",c),m=o.makeTensorInfo(p,"float32",u),k=f({inputs:{real:h,imag:m},backend:o}),g=t.backend_util.complexWithOddIndex(i),b=g.real,y=g.imag,S=[b.length],T=o.makeTensorInfo(S,"float32",b),N=o.makeTensorInfo(S,"float32",y),x=f({inputs:{real:T,imag:N},backend:o}),M=e(c,u,d,r,o),v=M.real,A=M.imag,D=[v.length],z=o.makeTensorInfo(D,"float32",v),_=o.makeTensorInfo(D,"float32",A),W=f({inputs:{real:z,imag:_},backend:o}),H=e(b,y,d,r,o),w=H.real,C=H.imag,E=[w.length],B=o.makeTensorInfo(E,"float32",w),O=o.makeTensorInfo(E,"float32",C),P=f({inputs:{real:B,imag:O},backend:o}),R=t.backend_util.exponents(s,r),q=[R.real.length],L=o.makeTensorInfo(q,"float32",R.real),V=o.makeTensorInfo(q,"float32",R.imag),$=f({inputs:{real:L,imag:V},backend:o}),G=Y({inputs:{a:$,b:P},backend:o}),U=F({inputs:{a:W,b:G},backend:o}),j=re({inputs:{a:W,b:G},backend:o}),K=I({inputs:{input:U},backend:o}),Z=I({inputs:{input:j},backend:o}),J=De({inputs:{input:U},backend:o}),Q=De({inputs:{input:j},backend:o}),X=He({inputs:[K,Z],backend:o,attrs:{axis:0}}),ee=He({inputs:[J,Q],backend:o,attrs:{axis:0}}),te=o.data.get(X.dataId).values,ae=o.data.get(ee.dataId).values;return o.disposeIntermediateTensorInfo(h),o.disposeIntermediateTensorInfo(m),o.disposeIntermediateTensorInfo(k),o.disposeIntermediateTensorInfo(T),o.disposeIntermediateTensorInfo(N),o.disposeIntermediateTensorInfo(x),o.disposeIntermediateTensorInfo(z),o.disposeIntermediateTensorInfo(_),o.disposeIntermediateTensorInfo(W),o.disposeIntermediateTensorInfo(B),o.disposeIntermediateTensorInfo(O),o.disposeIntermediateTensorInfo(P),o.disposeIntermediateTensorInfo(L),o.disposeIntermediateTensorInfo(V),o.disposeIntermediateTensorInfo($),o.disposeIntermediateTensorInfo(G),o.disposeIntermediateTensorInfo(U),o.disposeIntermediateTensorInfo(j),o.disposeIntermediateTensorInfo(K),o.disposeIntermediateTensorInfo(J),o.disposeIntermediateTensorInfo(Z),o.disposeIntermediateTensorInfo(Q),o.disposeIntermediateTensorInfo(X),o.disposeIntermediateTensorInfo(ee),{real:te,imag:ae}}(o,i,s,a,n),d=[e.shape[0],e.shape[1]];if(a){const e=n.makeTensorInfo(d,"float32",r.real),a=n.makeTensorInfo(d,"float32",r.imag),o=n.makeTensorInfo([],"float32",t.util.createScalarValue(s,"float32")),i=k({inputs:{x:o},backend:n}),l=$e.kernelFunc({inputs:{a:e,b:o},backend:n}),c=$e.kernelFunc({inputs:{a:a,b:i},backend:n}),u=n.data.get(l.dataId).values,p=n.data.get(c.dataId).values;return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(c),{real:u,imag:p}}return r}{const e=function(e,a,n){const s=new Float32Array(2*a);for(let r=0;r<a;r++){let o=0,i=0;for(let s=0;s<a;s++){const d=t.backend_util.exponent(r*s,a,n),l=t.backend_util.getComplexWithIndex(e,s);o+=l.real*d.real-l.imag*d.imag,i+=l.real*d.imag+l.imag*d.real}n&&(o/=a,i/=a),t.backend_util.assignToTypedArray(s,o,i,r)}return s}(t.backend_util.mergeRealAndImagArrays(o,i),s,a);return t.backend_util.splitRealAndImagArrays(e)}var d}const nt={kernelName:t.FFT,backendName:"cpu",kernelFunc:function(e){const{inputs:a,backend:n}=e,{input:s}=a,r=t.util.sizeFromShape(s.shape),o=s.shape[s.shape.length-1],i=_e({inputs:{x:s},backend:n,attrs:{shape:[r/o,o]}}),d=tt(i,!1,n),l=_e({inputs:{x:d},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(d),l}},st={kernelName:t.FlipLeftRight,backendName:"cpu",kernelFunc:({inputs:e,attrs:a,backend:n})=>{const{image:s}=e,r=n,o=t.util.getTypedArrayFromDType(s.dtype,t.util.sizeFromShape(s.shape)),[i,d,l,c]=s.shape,u=r.data.get(s.dataId).values;for(let e=0;e<i;e++){const t=e*l*d*c;for(let e=0;e<d;e++){const a=e*(l*c);for(let n=0;n<l;n++){const s=n*c;for(let r=0;r<c;r++){const d=[i,e,n,r][2],p=Math.round(l-d),h=t+a+s+r;let f=u[h];if(p>=0&&p<l){f=u[t+a+p*c+r]}o[h]=f}}}}return{dataId:r.write(o,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};const rt={kernelName:t.IFFT,backendName:"cpu",kernelFunc:function(e){const{inputs:a,backend:n}=e,{input:s}=a,r=t.util.sizeFromShape(s.shape),o=s.shape[s.shape.length-1],i=_e({inputs:{x:s},backend:n,attrs:{shape:[r/o,o]}}),d=tt(i,!0,n),l=_e({inputs:{x:d},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(d),l}},ot=D(t.IsFinite,e=>Number.isFinite(e)?1:0,"bool"),it={kernelName:t.IsFinite,backendName:"cpu",kernelFunc:ot},dt=D(t.IsInf,e=>Math.abs(e)===1/0?1:0,"bool"),lt={kernelName:t.IsInf,backendName:"cpu",kernelFunc:dt},ct=D(t.IsNan,e=>Number.isNaN(e)?1:0,"bool"),ut={kernelName:t.IsNan,backendName:"cpu",kernelFunc:ct},pt=D(t.Log1p,e=>Math.log1p(e)),ht={kernelName:t.Log1p,backendName:"cpu",kernelFunc:pt},ft=D(t.LogicalNot,e=>e?0:1,"bool"),mt={kernelName:t.LogicalNot,backendName:"cpu",kernelFunc:ft},kt={kernelName:t.Max,backendName:"cpu",kernelFunc:({inputs:e,attrs:a,backend:s})=>{const{x:r}=e,{reductionIndices:o,keepDims:i}=a,d=s;let l=r.shape;const c=l.length,u=t.util.parseAxisParam(o,l);let p=u;const h=t.backend_util.getAxesPermutation(p,c);let f=d.data.get(r.dataId).values;if(null!=h){const e=new Array(c);for(let t=0;t<e.length;t++)e[t]=l[h[t]];f=ie(f,l,r.dtype,h,e),p=t.backend_util.getInnerMostAxes(p.length,c),l=e}n(r,"max"),t.backend_util.assertAxesAreInnerMostDims("max",p,c);const[m,k]=t.backend_util.computeOutAndReduceShapes(l,p),g=U(f,t.util.sizeFromShape(k),m,r.dtype),I=d.write(g,m,r.dtype);let b=m;if(i){b=t.backend_util.expandShapeToKeepDim(m,u)}return{dataId:I,shape:b,dtype:r.dtype}}};const gt={kernelName:t.MaxPool,backendName:"cpu",kernelFunc:function(e){const{inputs:a,backend:s,attrs:r}=e,{x:o}=a;n(o,"maxPool");const{filterSize:i,strides:d,pad:l,dimRoundingMode:c}=r;t.util.assert(t.backend_util.eitherStridesOrDilationsAreOne(d,1),()=>"Error in maxPool: Either strides or dilations must be 1. "+`Got strides ${d} and dilations '1'`);const u=t.backend_util.computePool2DInfo(o.shape,i,d,1,l,c);let p;if(1===u.filterWidth&&1===u.filterHeight&&t.util.arraysEqual(u.inShape,u.outShape))p=k({inputs:{x:o},backend:s});else{const e=s.data.get(o.dataId).values,a=t.util.computeStrides(o.shape),n=Te(e,o.shape,o.dtype,a,u,"max");p=s.makeTensorInfo(u.outShape,o.dtype,n.values)}return p}};const It={kernelName:t.MaxPoolBackprop,backendName:"cpu",kernelFunc:function(e){const{inputs:a,backend:s,attrs:r}=e,{dy:o,input:i,output:d}=a,l=i;n([i,d],"maxPoolBackprop");const{filterSize:c,strides:u,pad:p,dimRoundingMode:h}=r,f=t.backend_util.computePool2DInfo(l.shape,c,u,1,p,h),m=s.data.get(l.dataId).values,k=t.buffer(f.outShape,l.dtype,Ne(m,l.shape,l.dtype,f).values),g=f.strideHeight,I=f.strideWidth,b=f.dilationHeight,y=f.dilationWidth,S=f.effectiveFilterHeight,T=f.effectiveFilterWidth,N=T-1-f.padInfo.left,x=S-1-f.padInfo.top,M=t.buffer(l.shape,"float32"),F=s.data.get(o.dataId).values,v=t.buffer(o.shape,"float32",F);for(let e=0;e<f.batchSize;++e)for(let t=0;t<f.inChannels;++t)for(let a=0;a<f.inHeight;++a)for(let n=0;n<f.inWidth;++n){const s=a-x,r=n-N;let o=0;for(let a=0;a<S;a+=b){const n=(s+a)/g;if(!(n<0||n>=f.outHeight||Math.floor(n)!==n))for(let s=0;s<T;s+=y){const i=(r+s)/I;if(i<0||i>=f.outWidth||Math.floor(i)!==i)continue;const d=S*T-1-k.get(e,n,i,t)===a*T+s?1:0;0!==d&&(o+=v.get(e,n,i,t)*d)}}M.set(o,e,a,n,t)}return s.makeTensorInfo(M.shape,M.dtype,M.values)}};const bt={kernelName:t.MaxPoolWithArgmax,backendName:"cpu",kernelFunc:({inputs:e,attrs:a,backend:s})=>{const{x:r}=e,{filterSize:o,strides:i,pad:d,includeBatchInIndex:l}=a,c=s;n(r,"MaxPoolWithArgmax");const u=c.data.get(r.dataId).values,p=t.backend_util.computePool2DInfo(r.shape,o,i,[1,1],d),[h,f]=function(e,a,n,s,r){const o=Te(e,0,n,t.util.computeStrides(a),r,"max"),i=Ne(e,a,n,r,!0,s);return[o.values,i.values]}(u,r.shape,r.dtype,l,p),m=c.write(h,p.outShape,r.dtype),k=c.write(f,p.outShape,r.dtype);return[{dataId:m,shape:p.outShape,dtype:r.dtype},{dataId:k,shape:p.outShape,dtype:"int32"}]}},yt=t.kernel_impls.nonMaxSuppressionV4Impl,St={kernelName:t.NonMaxSuppressionV4,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:a})=>{const{boxes:s,scores:r}=e,{maxOutputSize:o,iouThreshold:i,scoreThreshold:d,padToMaxOutputSize:l}=a,c=t;n(s,"NonMaxSuppressionPadded");const u=c.data.get(s.dataId).values,p=c.data.get(r.dataId).values,{selectedIndices:h,validOutputs:f}=yt(u,p,o,i,d,l);return[h,f]}},Tt=t.kernel_impls.nonMaxSuppressionV5Impl,Nt={kernelName:t.NonMaxSuppressionV5,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:a})=>{const{boxes:s,scores:r}=e,{maxOutputSize:o,iouThreshold:i,scoreThreshold:d,softNmsSigma:l}=a,c=t;n(s,"NonMaxSuppressionWithScore");const u=c.data.get(s.dataId).values,p=c.data.get(r.dataId).values,h=o,f=i,m=d,k=l,{selectedIndices:g,selectedScores:I}=Tt(u,p,h,f,m,k);return[g,I]}},xt=h((e,t)=>e!==t?1:0),Mt=T(t.NotEqual,xt,null,"bool"),Ft={kernelName:t.NotEqual,backendName:"cpu",kernelFunc:Mt};const vt={kernelName:t.PadV2,backendName:"cpu",kernelFunc:function(e){const{inputs:a,backend:s,attrs:r}=e,{x:o}=a,{paddings:i,constantValue:d}=r;n(o,"pad");const l=i.map((e,t)=>e[0]+o.shape[t]+e[1]),c=i.map(e=>e[0]),u=s.data.get(o.dataId).values,p=t.util.sizeFromShape(o.shape),h=o.shape.length,f=t.util.computeStrides(o.shape),m=t.util.sizeFromShape(l),k=l.length,g=t.util.computeStrides(l),I=t.util.getTypedArrayFromDType(o.dtype,m);0!==d&&I.fill(d);for(let e=0;e<p;e++){const a=t.util.indexToLoc(e,h,f).map((e,t)=>e+c[t]);I[t.util.locToIndex(a,k,g)]=u[e]}return{dataId:s.write(I,l,o.dtype),shape:l,dtype:o.dtype}}},At=D(t.Reciprocal,e=>1/e),Dt={kernelName:t.Reciprocal,backendName:"cpu",kernelFunc:At},zt={kernelName:t.RotateWithOffset,backendName:"cpu",kernelFunc:({inputs:e,attrs:a,backend:n})=>{const{image:s}=e,{radians:r,fillValue:o,center:i}=a,d=n,l=t.util.getTypedArrayFromDType(s.dtype,t.util.sizeFromShape(s.shape)),[c,u,p,h]=s.shape,[f,m]=t.backend_util.getImageCenter(i,u,p),k=Math.sin(r),g=Math.cos(r),I=d.data.get(s.dataId).values;for(let e=0;e<c;e++){const t=e*p*u*h;for(let e=0;e<u;e++){const a=e*(p*h);for(let n=0;n<p;n++){const s=n*h;for(let r=0;r<h;r++){const i=[c,e,n,r],d=i[2],b=i[1];let y=(d-f)*g-(b-m)*k,S=(d-f)*k+(b-m)*g;y=Math.round(y+f),S=Math.round(S+m);let T=o;if("number"!=typeof o&&(T=3===r?255:o[r]),y>=0&&y<p&&S>=0&&S<u){T=I[t+S*(p*h)+y*h+r]}l[t+a+s+r]=T}}}}return{dataId:d.write(l,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},_t=D(t.Round,e=>{const t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2==0?t:t+1}),Wt={kernelName:t.Round,backendName:"cpu",kernelFunc:_t},Ht=t.backend_util.SELU_SCALEALPHA,wt=t.backend_util.SELU_SCALE,Ct=D(t.Selu,e=>e>=0?wt*e:Ht*(Math.exp(e)-1)),Et={kernelName:t.Selu,backendName:"cpu",kernelFunc:Ct},Bt=D(t.Sigmoid,e=>1/(1+Math.exp(-e))),Ot={kernelName:t.Sigmoid,backendName:"cpu",kernelFunc:Bt},Pt=D(t.Sign,e=>e<0?-1:e>0?1:0),Rt={kernelName:t.Sign,backendName:"cpu",kernelFunc:Pt},qt=D(t.Sin,e=>Math.sin(e)),Lt={kernelName:t.Sin,backendName:"cpu",kernelFunc:qt},Vt=D(t.Sinh,e=>Math.sinh(e)),$t={kernelName:t.Sinh,backendName:"cpu",kernelFunc:Vt},Gt=Math.log(1.1920928955078125e-7)+2,Ut=D(t.Softplus,e=>{const t=e>-Gt,a=e<Gt,n=Math.exp(e);let s;return s=a?n:t?e:Math.log(1+n),s}),jt={kernelName:t.Softplus,backendName:"cpu",kernelFunc:Ut};function Kt(e){const{inputs:t,attrs:a,backend:s}=e,{x:r}=t,{perm:o}=a;n(r,"transpose");const i=r.shape.length,d=new Array(i);for(let e=0;e<d.length;e++)d[e]=r.shape[o[e]];const l=ie(s.data.get(r.dataId).values,r.shape,r.dtype,o,d);return{dataId:s.write(l,d,r.dtype),shape:d,dtype:r.dtype}}const Yt={kernelName:t.Transpose,backendName:"cpu",kernelFunc:Kt};const Zt={kernelName:t.SpaceToBatchND,backendName:"cpu",kernelFunc:function(e){const{inputs:a,backend:s,attrs:r}=e,{x:o}=a,{blockShape:i,paddings:d}=r;n([o],"spaceToBatchND");const l=t.util.sizeFromShape(i),c=[[0,0]];c.push(...d);for(let e=1+i.length;e<o.shape.length;++e)c.push([0,0]);const u=vt.kernelFunc({inputs:{x:o},backend:s,attrs:{paddings:c,constantValue:0}}),p=t.backend_util.getReshaped(u.shape,i,l,!1),h=t.backend_util.getPermuted(p.length,i.length,!1),f=t.backend_util.getReshapedPermuted(u.shape,i,l,!1),m=_e({inputs:{x:u},backend:s,attrs:{shape:p}}),k=Kt({inputs:{x:m},backend:s,attrs:{perm:h}}),g=_e({inputs:{x:k},backend:s,attrs:{shape:f}});return s.disposeIntermediateTensorInfo(u),s.disposeIntermediateTensorInfo(m),s.disposeIntermediateTensorInfo(k),g}},Jt=D(t.Sqrt,e=>Math.sqrt(e)),Qt={kernelName:t.Sqrt,backendName:"cpu",kernelFunc:Jt},Xt={kernelName:t.Square,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{const{x:a}=e,s=t;n(a,"square");const r=s.data.get(a.dataId).values,o=new Float32Array(r.length);for(let e=0;e<r.length;++e){const t=r[e];o[e]=t*t}return{dataId:s.write(o,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},ea=h((e,t)=>{const a=e-t;return a*a}),ta=T(t.SquaredDifference,ea),aa={kernelName:t.SquaredDifference,backendName:"cpu",kernelFunc:ta},na=D(t.Step,(e,t)=>{const a=t;return isNaN(e)?NaN:e>0?1:a.alpha}),sa={kernelName:t.Step,backendName:"cpu",kernelFunc:na},ra=D(t.Tan,e=>Math.tan(e)),oa={kernelName:t.Tan,backendName:"cpu",kernelFunc:ra},ia=D(t.Tanh,e=>Math.tanh(e)),da={kernelName:t.Tanh,backendName:"cpu",kernelFunc:ia};const la={kernelName:t.Unique,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:a,backend:s}=e,{axis:r}=a,{x:o}=t;n(o,"unique");const i=s.data.get(o.dataId).values,{outputValues:d,outputShape:l,indices:c}=de(i,r,o.shape,o.dtype);return[s.makeTensorInfo(l,o.dtype,d),s.makeTensorInfo([c.length],"int32",c)]}},ca=[p,ue,he,v,me,ge,be,Se,xe,Me,Fe,S,H,Ae,m,we,Ee,Oe,Pe,qe,Re,$e,Ue,et,E,P,nt,st,L,g,rt,ze,it,lt,ut,G,ht,mt,gt,It,bt,kt,Z,St,Nt,Ft,vt,b,Dt,We,zt,Wt,X,Et,Ot,Rt,Lt,$t,ae,jt,Zt,Qt,Xt,aa,sa,oe,oa,da,Yt,la];for(const e of ca)t.registerKernel(e);e.MathBackendCPU=c,e.shared=le,e.version_cpu="2.6.0",Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=tf-backend-cpu.es2017.min.js.map
